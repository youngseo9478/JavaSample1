상속의 depth는 7까지만 하도록 권장

기존 클래스의 재사용되는 부분을 따로 작성해 놓아 상속받아 사용하는 것.

자식클래스가 부모클래스를 상속받은 후 객체를 생성하면 생성자 함수가 생기고 
생성자 함수에 들어가보면 super가 있다. 아무런 일도 하지 않더라도
부모의 객체를 들렀다 다시 돌아온 후 객체 생성을 완료하게 된다.

상속을 받은 자식클래스의 객체를 만들면 부모객체가 상단에, 자식객체가 하단에 위치하게 된다.
그러나 접근할때에는 다른 키워드가 없다면 하단의 자식부터 탐색하게 된다.

부모와 자식은 같은 이름의 멤버 변수를 가질 수 있다. 그러나 접근할때는 하단인 자식 클래스의 이름으로
선택된다. 부모멤버에 접근하고 싶다면 super.을 이용해야한다.
그러나 this, super는 heap영역에 있기 때문에  static영역인 main에서는 사용할 수 없다.

★Is-a
모든 객체의 데이터 타입은 부모가 될 수 있다. 
->애니멀 클래스를 상속받은 도그 클래스 있으면 도그 클래스의 부모는 애니멀클래스이다.
예) 모든 도그는 애니멀 이다. is a 관계가 성립
Animal dog = new Dog();  가능! 그러므로 상속관계는 is-a관계이다.
반대의 경우
Dog dog = new Animal(); 불가능! 
모든 동물은 도그다? 틀렸다..

하지만, is-a관계인 경우 부모의 영역만 접근이 가능하기때문에 
자식의 멤버에는 접근할 수 없게 된다.(공통된부분만 접근가능)
그렇다면 이렇게 부모타입으로 했을 때 이점은 무엇일까?
자식의 타입을 부모가 모두 핸들링 가능하다.
(단점 : 접근 불가능한 영역이 존재한다)

부모타입으로 객체를 생성하지 않으면서 부모멤버에 접근하는 방법 =>"업캐스팅" (부모타입으로가는 것)
이렇게 하면 역시 엑세스(접근)영역이 좁아진다.
(Animal)dog.kind 이런식... (kind라는 변수가 부모에도 자식에도 존재하는데 부모의 kind에 접근하고자 할떄!)

"다운캐스팅"도 존재한다! 자식 클래스로 캐스팅하는 것.
(Dog)animal.kind 이런식...

결국 내부적으로 분리되어 사용되고 있고, 적절하게 핸들링할 수 있다는게 핵심!(is-a관계)

캐스팅은 매우 불편...게다가 내부 문제가 생길 가능성도 농후함..!! 필요할때는 사용하기는 한다.
(실무에서는 자식타입을 다 부모타입으로 캐스팅해서 사용함)=>오버라이딩하려고!

뭐는 되고 뭐는 안되고를 안하려면 인터페이스!! 실무에서는 인터페이스가 가장 많이 사용됨.

